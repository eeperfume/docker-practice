# Node.js의 경량 이미지 사용
# Node.js의 경량 버전 이미지를 기반으로 컨테이너를 생성
# slim 태그는 불필요한 툴이 제거된 경량 이미지를 의미함
FROM node:20-slim

# 작업 디렉토리를 컨테이너 내부에서 /app으로 설정
# 이후 명령어는 모두 /app을 기준으로 실행
WORKDIR /app

# 현재 디렉토리의 모든 파일을 컨테이너 내부의 /app으로 복사
# 첫 번째 .은 호스트의 현재 디렉토리, 두 번째 .은 컨테이너 내부의 작업 디렉토리를 의미함
COPY . .

# 프로젝트의 의존성 설치
# JSON 배열 형식(["npm", "install"])은 실행 환경에 상관없이 항상 동일한 결과를 보장함
RUN ["npm", "install"]

# 컨테이너에서 사용하는 포트를 노출 (기능적으로는 메모용)
# 실제 네트워크 연결을 열지는 않지만, 포트 매핑 시 유용한 정보를 제공함
EXPOSE 3000

# 컨테이너 실행 시 Node.js 서버 실행
# 컨테이너가 실행될 때 기본적으로 실행할 명령어를 지정함
CMD ["node", "server.js"]

# ================================================================================
# ENTRYPOINT 예시 (사용하지 않을 경우 주석 처리)
# ENTRYPOINT ["node", "server.js"]
# ================================================================================
# CMD vs ENTRYPOINT
# CMD는 기본 실행 명령어를 설정하며, 컨테이너 실행 시 다른 명령을 지정하면 이를 덮어씀.
# ENTRYPOINT는 컨테이너 실행 시 항상 실행되며, 추가 인수를 제공하는 방식으로 동작함.
# ================================================================================
# 빌드 명령어
# docker build -t 이미지명:태그 .
# .은 Dockerfile의 경로를 명시해야 함

# Dockerfile이 현재 디렉토리가 아닐 경우:
# docker build -f /path/to/Dockerfile -t 이미지명:태그 .

# 태그는 이미지 버전을 관리하는 데 유용함
# 예시
# docker build -t node-docker-practice:1.0 .
# docker build -t node-docker-practice:latest .
# ================================================================================
# Detached
# docker run 명령어에서 -d 옵션은 detached의 약자로, 컨테이너를 백그라운드에서 실행하도록 하는 옵션
# 예시
# docker run -d -p 8080:3000 node-docker-practice:1.0
# ================================================================================
# 왜 포트를 명시해야 할까?
# Docker 컨테이너는 기본적으로 호스트와 독립된 네트워크 환경에서 동작함.
# 즉, 컨테이너 내부에서 실행 중인 애플리케이션의 포트를 외부(호스트)에서 접근하려면 포트 매핑이 필요함.

# -p 8080:3000의 역할:
# 호스트(8080) ↔ 컨테이너(3000) 연결

# 호스트의 8080번 포트로 들어오는 요청을 컨테이너 내부의 3000번 포트로 전달
# 컨테이너를 외부에서 접근 가능하게 함

# 컨테이너 내부는 기본적으로 외부에서 접근할 수 없음.
# 이 명령으로 특정 포트를 열어 애플리케이션이 외부 요청을 받을 수 있도록 설정함.
# ================================================================================
# docker ps
# docker ps 명령어는 현재 실행 중인 Docker 컨테이너의 상태를 확인할 때 사용

# 1. 실행 중인 컨테이너 확인:
# docker ps

# 2. 모든 컨테이너 확인:
# docker ps -a

# 3. 특정 상태의 컨테이너 확인:
# docker ps --filter "status=exited"

# 4. 컨테이너 ID만 가져오기:
# docker ps -q
# ================================================================================
# docker logs
# docker logs 명령어는 Docker 컨테이너에서 실행 중인 애플리케이션의 로그를 확인할 때 사용

# 기본 형식:
# docker logs [컨테이너 ID 또는 이름]

# 주요 옵션:

# -f (follow)
# 실시간으로 로그를 스트리밍하여 확인할 수 있음
# 컨테이너가 실행 중일 때 유용
# docker logs -f [컨테이너 ID 또는 이름]

# --tail
# 로그의 마지막 몇 줄만 출력
# 로그가 너무 길 경우 특정 부분만 보고 싶을 때 사용
# docker logs --tail 10 [컨테이너 ID 또는 이름]  # 마지막 10줄의 로그만 보기

# -t (timestamps)
# 로그에 타임스탬프를 포함하여 출력
# docker logs -t [컨테이너 ID 또는 이름]

# --since 및 --until
# 특정 시간 범위의 로그를 조회
# --since: 주어진 시간 이후의 로그만 출력
# --until: 주어진 시간 이전의 로그만 출력
# docker logs --since 1h [컨테이너 ID 또는 이름]  # 1시간 전부터의 로그
# docker logs --until 2024-11-24T10:00 [컨테이너 ID 또는 이름]  # 특정 시각 이전의 로그
# ================================================================================
# docker exec
# docker exec 명령어는 실행 중인 컨테이너 내부에서 명령을 실행할 때 사용

# 기본 형식:
# docker exec [옵션] <컨테이너 ID 또는 이름> <명령어>

# 주요 기능:

# 1. 컨테이너 내부에서 명령 실행
# 컨테이너 내부의 쉘을 열거나 특정 명령어를 실행할 수 있음
# 예를 들어, ls, cat, bash와 같은 명령어를 실행할 수 있음

# 2. 컨테이너의 애플리케이션 상태 점검
# 컨테이너 내부에서 실행 중인 애플리케이션 상태를 확인할 수 있음

# 3. 디버깅 및 문제 해결
# 컨테이너 내부의 파일, 환경 변수, 로그 등을 확인할 때 유용함

# 주요 옵션:

# -it
# -i: 표준 입력을 활성화 함
# -t: TTY(Terminal)를 활성화하여 인터랙티브 셸 환경을 제공함
# -it를 함께 사용하면 컨테이너 내부에서 셸 작업을 수행할 수 있음
# docker exec -it [컨테이너 ID 또는 이름] /bin/bash

# -d
# 명령을 백그라운드에서 실행함
# docker exec -d [컨테이너 ID 또는 이름] touch /tmp/example.txt

# 예시
# 1. 컨테이너 내부로 들어가기 (Bash 쉘 열기):
# docker exec -it my-container /bin/bash
# 컨테이너 내부에서 Bash 셸 환경으로 전환함

# 2. 컨테이너 내부 파일 확인:
# docker exec my-container ls /usr/src/app
# 컨테이너 내부 /usr/src/app 디렉토리의 파일 목록을 출력함

# 3. 명령을 백그라운드에서 실행:
# docker exec -d my-container touch /tmp/test.txt
# 컨테이너 내부 /tmp 디렉토리에 test.txt 파일을 생성함

# 4. 컨테이너 내부에서 Node.js 버전 확인:
# docker exec my-container node -v
# 컨테이너 내부에 설치된 Node.js의 버전을 출력함
# ================================================================================
# docker exec와 docker attach의 차이점
# docker exec: 실행 중인 컨테이너 내부에서 새로운 프로세스를 실행하기 위한 목적
# docker attach: 컨테이너의 기존 프로세스와 연결하여 해당 프로세스의 표준 출력/입력을 제어하기 위한 목적 (일반적으로 로그 확인 시 사용)
# ================================================================================
# Ctrl + P, Ctrl + Q
# Ctrl + P, Ctrl + Q는 Docker 컨테이너에서 Detach(분리) 모드로 빠져나오는 단축키 조합
# 컨테이너에 docker exec, attach 명령어로 연결했을 때, 컨테이너를 종료하지 않고 터미널을 빠져나오기 위한 방법임
# 사용 배경:
# docker exec, attach 명령으로 컨테이너에 연결된 경우, Ctrl + C를 누르면 컨테이너가 종료될 수 있음.
# ================================================================================
# docker stop
# docker stop 명령어는 실행 중인 Docker 컨테이너를 안전하게 중지할 때 사용함

# 기본 형식
# docker stop [컨테이너 ID 또는 이름]

# 예시
# 1. 단일 컨테이너 중지: docker stop my-container
# 이름이 my-container인 컨테이너를 중지

# 2. 여러 컨테이너 중지: docker stop container1 container2
# container1과 container2를 동시에 중지

# 3. 컨테이너 ID를 사용하여 중지: docker stop 123abc456def
# ID가 123abc456def인 컨테이너를 중지
# ================================================================================
# docker rm
# docker rm 명령어는 중지된 Docker 컨테이너를 삭제할 때 사용함

# 기본 형식:
# docker rm [컨테이너 ID 또는 이름]

# 주요 특징:
# 중지된 컨테이너만 삭제 가능

# 실행 중인 컨테이너는 삭제할 수 없음
# 실행 중인 컨테이너를 강제로 삭제하려면 -f 옵션을 사용해야 함

# 예시

# 1. 단일 컨테이너 삭제: docker rm my-container
# 이름이 my-container인 중지된 컨테이너를 삭제

# 2. 여러 컨테이너 삭제: docker rm container1 container2
# container1과 container2를 동시에 삭제

# 3. 실행 중인 컨테이너 강제 삭제: docker rm -f my-container
# 실행 중인 컨테이너 my-container를 강제 종료하고 삭제
# ================================================================================